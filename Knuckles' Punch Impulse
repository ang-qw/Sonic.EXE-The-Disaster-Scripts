-- Punch Impulse (Movilidad) para Knuckles
-- Descripción:
-- Knuckles comienza a cargar un puñetazo. Mientras más tiempo espere (máximo 5 segundos), mayor será el alcance horizontal.
-- Se muestra una barra de carga en la mitad baja de la pantalla que se llena durante la carga y desaparece al volver a presionar el botón.
-- Si no se libera la habilidad antes de 5 segundos, ésta se cancela.
-- Al soltar, Knuckles recibe un impulso horizontal instantáneo hacia adelante proporcional a la carga.
-- Si choca con una pared, es rebotado brevemente y queda aturdido por 2 segundos.
-- La habilidad no se puede ejecutar en el aire ni seguir el impulso en el aire (solo cae).
-- Icono: https://www.roblox.com/library/18927463439
-- Animaciones:
--   - Carga: rbxassetid://18899581154
--   - Impulso: rbxassetid://18899633285
--   - Al chocar con pared: rbxassetid://17195418321
--   - Aturdimiento: rbxassetid://99177682528654

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")
local runService = game:GetService("RunService")
local userInputService = game:GetService("UserInputService")
local repStorage = game:GetService("ReplicatedStorage")

-- Exclusividad para "knuckles"
local displayPlayers = repStorage:WaitForChild("displayPlayers")
local playerStats = displayPlayers:FindFirstChild(player.Name):WaitForChild("stats")
local characterValue = playerStats:WaitForChild("character")
if characterValue.Value:lower() ~= "knuckles" then
	return
end

-- Variables de la habilidad
local isCharging = false
local chargeStartTime = 0
local maxChargeTime = 5
local cooldownActive = false
local cooldownTime = 27
local chargeBarUpdateConnection
local gravity = workspace.Gravity
local defaultWalkSpeed = humanoid.WalkSpeed  -- Se guarda la velocidad original

-- Animaciones
local animator = humanoid:FindFirstChildOfClass("Animator") or humanoid:WaitForChild("Animator")

local chargeAnimation = Instance.new("Animation")
chargeAnimation.AnimationId = "rbxassetid://18899581154"
local chargeTrack = animator:LoadAnimation(chargeAnimation)

local impulseAnimation = Instance.new("Animation")
impulseAnimation.AnimationId = "rbxassetid://18899633285"
local impulseTrack = animator:LoadAnimation(impulseAnimation)

local collisionAnimation = Instance.new("Animation")
collisionAnimation.AnimationId = "rbxassetid://17195418321"
local collisionTrack = animator:LoadAnimation(collisionAnimation)

local stunAnimation = Instance.new("Animation")
stunAnimation.AnimationId = "rbxassetid://99177682528654"
local stunTrack = animator:LoadAnimation(stunAnimation)

-- Función para verificar si el personaje está en el suelo
local function isOnGround()
	if not character or not rootPart then return false end
	local rayOrigin = rootPart.Position
	local rayDirection = Vector3.new(0, -5, 0)
	local raycastParams = RaycastParams.new()
	raycastParams.FilterDescendantsInstances = {character}
	raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
	local result = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
	return result and true or false
end

-- Función para detectar colisión con una pared
local function detectWall()
	local rayOrigin = rootPart.Position
	local rayDirection = rootPart.CFrame.LookVector * 3
	local raycastParams = RaycastParams.new()
	raycastParams.FilterDescendantsInstances = {character}
	raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
	local result = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
	return result
end

-------------------------------------------------
-- Creación de la interfaz (GUI) con embellecimiento
-------------------------------------------------
local screenGui = Instance.new("ScreenGui", player:WaitForChild("PlayerGui"))
screenGui.Name = "SuperPunchGUI"

local container = Instance.new("Frame")
container.Size = UDim2.new(0, 60, 0, 60)
container.Position = UDim2.new(1, -80, 0.6, -30)
container.BackgroundTransparency = 1
container.Parent = screenGui
container.ZIndex = 100

local titleLabel = Instance.new("TextLabel")
titleLabel.Size = UDim2.new(0, 60, 0, 20)
titleLabel.Position = UDim2.new(0, 0, -0.4, 0)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "Punch Impulse"  -- Título actualizado
titleLabel.TextScaled = true
titleLabel.TextColor3 = Color3.new(1, 1, 1)
titleLabel.FontFace = Font.new("rbxassetid://12187371840", Enum.FontWeight.Bold, Enum.FontStyle.Normal)
titleLabel.TextStrokeTransparency = 0
titleLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
titleLabel.Parent = container
titleLabel.ZIndex = 105

local shadowStain = Instance.new("Frame")
shadowStain.Size = UDim2.new(1, 10, 1, 10)
shadowStain.Position = UDim2.new(0, -5, 0, -5)
shadowStain.BackgroundColor3 = Color3.new(0, 0, 0)
shadowStain.BackgroundTransparency = 1
shadowStain.Parent = container

local stainGradient = Instance.new("UIGradient", shadowStain)
stainGradient.Rotation = 45
stainGradient.Color = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)),
	ColorSequenceKeypoint.new(1, Color3.new(0, 0, 0))
})
stainGradient.Transparency = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 0.3),
	NumberSequenceKeypoint.new(1, 1)
})

local outerBorder = Instance.new("Frame")
outerBorder.Size = UDim2.new(1, 0, 1, 0)
outerBorder.Position = UDim2.new(0, 0, 0, 0)
outerBorder.BackgroundColor3 = Color3.fromRGB(139, 0, 0)
outerBorder.Parent = container
outerBorder.ZIndex = 101

local outerCorner = Instance.new("UICorner", outerBorder)
outerCorner.CornerRadius = UDim.new(1, 0)

local outerGradient = Instance.new("UIGradient", outerBorder)
outerGradient.Rotation = 90
outerGradient.Color = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(139, 0, 0)),
	ColorSequenceKeypoint.new(0.5, Color3.fromRGB(170, 0, 0)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(139, 0, 0))
})
outerGradient.Transparency = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 0),
	NumberSequenceKeypoint.new(0.5, 0),
	NumberSequenceKeypoint.new(1, 0)
})

local innerBorder = Instance.new("Frame")
innerBorder.Size = UDim2.new(1, -8, 1, -8)
innerBorder.Position = UDim2.new(0, 4, 0, 4)
innerBorder.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
innerBorder.Parent = outerBorder
innerBorder.ZIndex = 102

local innerCorner = Instance.new("UICorner", innerBorder)
innerCorner.CornerRadius = UDim.new(1, 0)

local innerGradient = Instance.new("UIGradient", innerBorder)
innerGradient.Rotation = 90
innerGradient.Color = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(50, 50, 50)),
	ColorSequenceKeypoint.new(0.5, Color3.fromRGB(100, 100, 100)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(50, 50, 50))
})
innerGradient.Transparency = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 0),
	NumberSequenceKeypoint.new(0.5, 0),
	NumberSequenceKeypoint.new(1, 0)
})

local effectFrame = Instance.new("Frame")
effectFrame.Size = UDim2.new(1, -6, 1, -6)
effectFrame.Position = UDim2.new(0, 3, 0, 3)
effectFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
effectFrame.Parent = innerBorder
effectFrame.ZIndex = 103

local effectCorner = Instance.new("UICorner", effectFrame)
effectCorner.CornerRadius = UDim.new(1, 0)

local effectFrameGradient = Instance.new("UIGradient", effectFrame)
effectFrameGradient.Rotation = 90
effectFrameGradient.Color = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 255, 255))
})
effectFrameGradient.Transparency = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 0),
	NumberSequenceKeypoint.new(1, 0)
})

local shadowAsset = Instance.new("ImageLabel")
shadowAsset.Size = UDim2.new(1, 10, 1, 10)
shadowAsset.Position = UDim2.new(0, -5, 0, -5)
shadowAsset.BackgroundTransparency = 1
shadowAsset.Image = "rbxassetid://114739599325115"
shadowAsset.ImageTransparency = 0.1
shadowAsset.Parent = effectFrame
shadowAsset.ZIndex = 102

local shadowAssetGradient = Instance.new("UIGradient", shadowAsset)
shadowAssetGradient.Rotation = 90
shadowAssetGradient.Color = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(220, 220, 220)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(220, 220, 220))
})
shadowAssetGradient.Transparency = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 0),
	NumberSequenceKeypoint.new(1, 0)
})

local iconLabel = Instance.new("ImageLabel")
iconLabel.Size = UDim2.new(1, 0, 1, 0)
iconLabel.Position = UDim2.new(0, 0, 0, 0)
iconLabel.BackgroundTransparency = 1
iconLabel.Image = "rbxassetid://18927463439"  -- Icono indicado para Super Punch
iconLabel.ImageColor3 = Color3.fromRGB(255, 255, 255)
iconLabel.Parent = effectFrame
iconLabel.ZIndex = 103

local iconGradient = Instance.new("UIGradient", iconLabel)
iconGradient.Rotation = 90
iconGradient.Color = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 0, 0)),
	ColorSequenceKeypoint.new(0.5, Color3.fromRGB(150, 150, 150)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 0, 0))
})
iconGradient.Transparency = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 0),
	NumberSequenceKeypoint.new(1, 0.55)
})

local cooldownText = Instance.new("TextLabel")
cooldownText.Size = UDim2.new(0, 30, 0, 30)
cooldownText.Position = UDim2.new(0.5, -15, 0.5, -15)
cooldownText.BackgroundTransparency = 1
cooldownText.TextScaled = true
cooldownText.FontFace = Font.new("rbxassetid://12187371840", Enum.FontWeight.Bold, Enum.FontStyle.Normal)
cooldownText.TextColor3 = Color3.new(1, 1, 1)
cooldownText.Visible = false
cooldownText.Parent = container
cooldownText.ZIndex = 104

local buttonOverlay = Instance.new("ImageButton")
buttonOverlay.Size = UDim2.new(1, 0, 1, 0)
buttonOverlay.Position = UDim2.new(0, 0, 0, 0)
buttonOverlay.BackgroundTransparency = 1
buttonOverlay.Parent = container
buttonOverlay.Draggable = true
buttonOverlay.Active = true
buttonOverlay.Visible = true
buttonOverlay.ZIndex = 105

-- Barra de carga (en la mitad baja de la pantalla)
local chargeBarContainer = Instance.new("Frame")
chargeBarContainer.Size = UDim2.new(0, 200, 0, 20)
chargeBarContainer.Position = UDim2.new(0.5, -100, 0.75, -10)
chargeBarContainer.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
chargeBarContainer.BorderSizePixel = 2
chargeBarContainer.Visible = false
chargeBarContainer.Parent = screenGui

local chargeBarFill = Instance.new("Frame")
chargeBarFill.Size = UDim2.new(0, 0, 1, 0)
chargeBarFill.Position = UDim2.new(0, 0, 0, 0)
-- Inicia en rojo; luego se interpolará hasta verde
chargeBarFill.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
chargeBarFill.BorderSizePixel = 0
chargeBarFill.Parent = chargeBarContainer

-------------------------------------------------
-- Funciones de la habilidad
-------------------------------------------------

-- Cancela la carga (por timeout o cancelación)
local function cancelCharge()
	if isCharging then
		isCharging = false
		if chargeBarUpdateConnection then
			chargeBarUpdateConnection:Disconnect()
		end
		chargeBarContainer.Visible = false
		chargeTrack:Stop()
		humanoid.WalkSpeed = defaultWalkSpeed
	end
end

-- Al soltar el botón, se calcula la carga y se aplica el impulso
local function releaseSuperPunch()
	if not isCharging then return end
	local chargeDurationElapsed = tick() - chargeStartTime
	if chargeDurationElapsed > maxChargeTime then
		chargeDurationElapsed = maxChargeTime
	end
	isCharging = false
	if chargeBarUpdateConnection then
		chargeBarUpdateConnection:Disconnect()
	end
	chargeBarContainer.Visible = false
	chargeTrack:Stop()
	-- Restaura el movimiento antes de aplicar el impulso
	humanoid.WalkSpeed = defaultWalkSpeed
	
	-- Reproducir animación de impulso y detenerla después
	impulseTrack:Play()
	
	-- Calcular la fuerza de impulso y buffearla 2,5 veces
	local baseImpulse = 50
	local extraImpulse = 50 * (chargeDurationElapsed / maxChargeTime)
	local totalImpulse = (baseImpulse + extraImpulse) * 2.5
	
	-- Aplicar BodyVelocity para el impulso horizontal
	local bodyVelocity = Instance.new("BodyVelocity")
	bodyVelocity.MaxForce = Vector3.new(100000, 0, 100000)
	bodyVelocity.Velocity = rootPart.CFrame.LookVector * totalImpulse
	bodyVelocity.Parent = rootPart
	
	local impulseDuration = 0.2
	local impulseStart = tick()
	local collided = false
	while tick() - impulseStart < impulseDuration do
		if detectWall() then
			collided = true
			break
		end
		runService.Heartbeat:Wait()
	end
	
	bodyVelocity:Destroy()
	impulseTrack:Stop()  -- Detener la animación de impulso
	
	-- Si se detecta colisión, reproducir animación de choque, retroceder y aturdir
	if collided then
		collisionTrack:Play()
		local bounceDistance = 15
		local bounceSteps = 10
		local bounceVector = -rootPart.CFrame.LookVector * (bounceDistance / bounceSteps)
		for i = 1, bounceSteps do
			rootPart.CFrame = rootPart.CFrame + bounceVector
			task.wait(0.02)
		end
		collisionTrack:Stop()
		stunTrack:Play()
		humanoid.WalkSpeed = 0
		task.wait(2)
		stunTrack:Stop()
		humanoid.WalkSpeed = defaultWalkSpeed
	end
	
	-- Iniciar el cooldown de 27 segundos
	cooldownActive = true
	cooldownText.Visible = true
	for i = cooldownTime, 1, -1 do
		cooldownText.Text = tostring(i)
		task.wait(1)
	end
	cooldownText.Visible = false
	cooldownActive = false
end

-- Función principal para activar o liberar la habilidad
local function toggleSuperPunch()
	if cooldownActive then return end
	if not isOnGround() then return end
	if not isCharging then
		-- Inicia la carga: se bloquea el movimiento
		isCharging = true
		chargeStartTime = tick()
		chargeBarContainer.Visible = true
		chargeTrack:Play()
		humanoid.WalkSpeed = 0
		
		-- Actualiza la barra de carga: tamaño y color (rojo a verde)
		chargeBarUpdateConnection = runService.Heartbeat:Connect(function()
			local elapsed = tick() - chargeStartTime
			local progress = math.clamp(elapsed / maxChargeTime, 0, 1)
			chargeBarFill.Size = UDim2.new(progress, 0, 1, 0)
			chargeBarFill.BackgroundColor3 = Color3.new(1 - progress, progress, 0)
			if elapsed >= maxChargeTime then
				cancelCharge()
			end
		end)
	else
		-- Si ya se está cargando, se libera la habilidad
		releaseSuperPunch()
	end
end

-------------------------------------------------
-- Conexiones para activar la habilidad
-------------------------------------------------
buttonOverlay.MouseButton1Click:Connect(toggleSuperPunch)
userInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	if input.KeyCode == Enum.KeyCode.P then
		toggleSuperPunch()
	end
end)
